import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

import { FrontSide, Matrix4, RawShaderMaterial, GLSL3 } from "three";
var vertexShader = "\nprecision highp float;\n\n// attributes of our mesh\nin float position;\nin float angle;\nin vec2 uv;\n\n// per instance attributes\nin vec4 translateAndScale; // xyz trans, w scale\n// instanceID, typeId, and which row of texture contains this curve\nin vec3 instanceAndTypeId;\n\nout vec3 IN_viewPos;\nout vec3 IN_viewNormal;\nout vec2 IN_instanceAndTypeId;\n\n// built-in uniforms from ThreeJS camera and Object3D\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat3 normalMatrix;\n\nuniform sampler2D curveData;\n\n// Some constants for the robust version\n#ifdef ROBUST\n  const float MAX_NUMBER = 1.79769313e+308;\n  const float EPSILON = 1.19209290e-7;\n#endif\n\n// the curve itself; to be loaded at beginning of main\nvec3 points[NUM_POINTS];\n\n// Angles to spherical coordinates\nvec3 spherical (float r, float phi, float theta) {\n  return r * vec3(\n    cos(phi) * cos(theta),\n    cos(phi) * sin(theta),\n    sin(phi)\n  );\n}\n\nvec4 initCubicPolynomial(float x0, float x1, float t0, float t1) {\n  return vec4(x0, t0, - 3.0 * x0 + 3.0 * x1 - 2.0 * t0 - t1, 2.0 * x0 - 2.0 * x1 + t0 + t1);\n}\nfloat calcCubicPolynomial( float t, vec4 c ) {\n\n\t\t\tfloat t2 = t * t;\n\t\t\tfloat t3 = t2 * t;\n\t\t\treturn c[0] + c[1] * t + c[2] * t2 + c[3] * t3;\n\t\t}\nvec4 initNonuniformCatmullRom( float x0, float x1, float x2, float x3, float dt0, float dt1, float dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tfloat t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tfloat t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\treturn initCubicPolynomial( x1, x2, t1, t2 );\n\n\t\t}\n\nvec3 getCurvePoint(int i) {\n  // instanceAndTypeId.z is which curve in this set of curves\n  return texelFetch(curveData,ivec2(i, int(instanceAndTypeId.z)), 0).rgb;\n}\n\nvec3 sampleCurve(float t) {\n\t\tvec3 point = vec3(0,0,0);\n\n\t\tint l = NUM_POINTS;\n\n\t\tfloat p = float( l - 1 ) * t;\n\t\tint intPoint = int(floor( p ));\n\t\tfloat weight = p - float(intPoint);\n\n\t\tif ( weight == 0.0 && intPoint == (l - 1) ) {\n\n\t\t\tintPoint = l - 2;\n\t\t\tweight = 1.0;\n\n\t\t}\n\n\t\tvec3 p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\tif ( intPoint > 0 ) {\n\n\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate first point\n\t\t\t//tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n      p0 = (points[0]-points[1]) + points[0];\n\n\t\t}\n\n\t\tvec3 p1 = points[ intPoint % l ];\n\t\tvec3 p2 = points[ ( intPoint + 1 ) % l ];\n\n\t\tif ( intPoint + 2 < l ) {\n\n\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate last point\n\t\t\t//tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\tp3 = (points[l-1]-points[l-2])+points[l-1];\n\n\t\t}\n\n    // init Centripetal / Chordal Catmull-Rom\n    const float exponent = 0.25;\n    float dt0 = dot(p0-p1, p0-p1);\n    float dt1 = dot(p1-p2, p1-p2);\n    float dt2 = dot(p2-p3, p2-p3);\n    dt0 = pow( dt0, exponent );\n    dt1 = pow( dt1, exponent );\n    dt2 = pow( dt2, exponent );\n\n    // safety check for repeated points\n    if ( dt1 < 1e-4 ) dt1 = 1.0;\n    if ( dt0 < 1e-4 ) dt0 = dt1;\n    if ( dt2 < 1e-4 ) dt2 = dt1;\n\n    vec4 px = initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n    vec4 py = initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n    vec4 pz = initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\tpoint = vec3(\n\t\t\tcalcCubicPolynomial( weight, px ),\n\t\t\tcalcCubicPolynomial( weight, py ),\n\t\t\tcalcCubicPolynomial( weight, pz )\n\t\t);\n\n\t\treturn point;\n\t}\n\n\n#ifdef ROBUST\n// ------\n// Robust handling of Frenet-Serret frames with Parallel Transport\n// ------\nvec3 getTangent (vec3 a, vec3 b) {\n  return normalize(b - a);\n}\n\nvoid rotateByAxisAngle (inout vec3 normal, vec3 axis, float rotAngle) {\n  // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n  // assumes axis is normalized\n  float halfAngle = rotAngle / 2.0;\n  float s = sin(halfAngle);\n  vec4 quat = vec4(axis * s, cos(halfAngle));\n  normal = normal + 2.0 * cross(quat.xyz, cross(quat.xyz, normal) + quat.w * normal);\n}\n\nvoid createTube (float t, vec2 volume, out vec3 outPosition, out vec3 outNormal) {\n  // Reference:\n  // https://github.com/mrdoob/three.js/blob/b07565918713771e77b8701105f2645b1e5009a7/src/extras/core/Curve.js#L268\n  float nextT = t + (1.0 / float(lengthSegments));\n\n  // find first tangent\n  vec3 point0 = sampleCurve(0.0);\n  vec3 point1 = sampleCurve(1.0 / float(lengthSegments));\n\n  vec3 lastTangent = getTangent(point0, point1);\n  vec3 absTangent = abs(lastTangent);\n  #ifdef ROBUST_NORMAL\n    float min = MAX_NUMBER;\n    vec3 tmpNormal = vec3(0.0);\n    if (absTangent.x <= min) {\n      min = absTangent.x;\n      tmpNormal.x = 1.0;\n    }\n    if (absTangent.y <= min) {\n      min = absTangent.y;\n      tmpNormal.y = 1.0;\n    }\n    if (absTangent.z <= min) {\n      tmpNormal.z = 1.0;\n    }\n  #else\n    vec3 tmpNormal = vec3(1.0, 0.0, 0.0);\n  #endif\n  vec3 tmpVec = normalize(cross(lastTangent, tmpNormal));\n  vec3 lastNormal = cross(lastTangent, tmpVec);\n  vec3 lastBinormal = cross(lastTangent, lastNormal);\n  vec3 lastPoint = point0;\n\n  vec3 normal;\n  vec3 tangent;\n  vec3 binormal;\n  vec3 point;\n  float maxLen = (float(lengthSegments) - 1.0);\n  float epSq = EPSILON * EPSILON;\n  for (float i = 1.0; i < float(lengthSegments); i += 1.0) {\n    float u = i / maxLen;\n    // could avoid additional sample here at expense of ternary\n    // point = i == 1.0 ? point1 : sampleCurve(u);\n    point = sampleCurve(u);\n    tangent = getTangent(lastPoint, point);\n    normal = lastNormal;\n    binormal = lastBinormal;\n\n    tmpVec = cross(lastTangent, tangent);\n    if ((tmpVec.x * tmpVec.x + tmpVec.y * tmpVec.y + tmpVec.z * tmpVec.z) > epSq) {\n      tmpVec = normalize(tmpVec);\n      float tangentDot = dot(lastTangent, tangent);\n      float theta = acos(clamp(tangentDot, -1.0, 1.0)); // clamp for floating pt errors\n      rotateByAxisAngle(normal, tmpVec, theta);\n    }\n\n    binormal = cross(tangent, normal);\n    if (u >= t) break;\n\n    lastPoint = point;\n    lastTangent = tangent;\n    lastNormal = normal;\n    lastBinormal = binormal;\n  }\n\n  // extrude outward to create a tube\n  float tubeAngle = angle;\n  float circX = cos(tubeAngle);\n  float circY = sin(tubeAngle);\n\n  // compute the TBN matrix\n  vec3 T = tangent;\n  vec3 B = binormal;\n  vec3 N = -normal;\n\n  // extrude the path & create a new normal\n  outNormal.xyz = normalize(B * circX + N * circY);\n  outPosition.xyz = point + B * volume.x * circX + N * volume.y * circY;\n}\n#else\n// ------\n// Fast version; computes the local Frenet-Serret frame\n// ------\nvoid createTube (float t, vec2 volume, out vec3 offset, out vec3 normal) {\n  // find prev and next sample along curve\n\n  float delta = 0.0001;\n\tfloat t1 = max(t - delta, 0.0);\n\tfloat t2 = min(t + delta, 1.0);\n\n  // sample the curve in two places\n  vec3 prev = sampleCurve(t1);\n  vec3 next = sampleCurve(t2);\n\n  // compute the TBN matrix (aka the Frenet-Serret frame)\n\n  // tangent is just the direction along our small delta\n  vec3 T = normalize(next - prev);\n\n  vec3 B = vec3(0, 0, 0);\n\n  // if next-prev and next+prev are parallel, then\n  // our normal and binormal will be ill-defined so we need to check for that\n  // check parallel by dot the unit vectors and check close to +/-1\n  float check = dot(T, normalize(next + prev));\n  if (abs(check) < 0.999) {\n    // cross product of parallel vectors is 0, so T must not be parallel to next+prev\n    // hence the above check.\n    B = normalize(cross(T, next + prev));\n  }\n  else {\n    // special case for which N and B are not well defined. \n    // so we will just pick something\n    float min = 1.0;\n    if (abs(T.x) <= min) {\n      min = abs(T.x);\n      B.x = 1.0;\n    }\n    if (abs(T.y) <= min) {\n      min = abs(T.y);\n      B.y = 1.0;\n    }\n    if (abs(T.z) <= min) {\n      B.z = 1.0;\n    }\n    vec3 tmpVec = normalize(cross(T, B));\n    B = normalize(cross(T, tmpVec));\n  }\n\n  // now that we have T and B perpendicular, we can easily make N\n  vec3 N = -normalize(cross(B, T));\n\n  // extrude outward to create a tube\n  float tubeAngle = angle;\n  float circX = cos(tubeAngle);\n  float circY = sin(tubeAngle);\n\n  // compute position and normal\n  normal.xyz = normalize(B * circX + N * circY);\n  offset.xyz = sampleCurve(t) + B * volume.x * circX + N * volume.y * circY;\n}\n#endif\n\nvoid main() {\n  // load the curve\n  for (int i = 0; i < NUM_POINTS; ++i) {\n    points[i] = getCurvePoint(i);\n  }\n\n  // current position to sample at\n  // [-0.5 .. 0.5] to [0.0 .. 1.0]\n  float t = (position * 2.0) * 0.5 + 0.5;\n\n  // build our tube geometry\n  vec2 volume = vec2(translateAndScale.w);\n\n  // build our geometry\n  vec3 transformed;\n  vec3 objectNormal;\n  createTube(t, volume, transformed, objectNormal);\n\n  // pass the normal and UV along\n  vec3 transformedNormal = normalMatrix * objectNormal;\n  //vNormal = normalize(transformedNormal);\n  // vUv = uv.yx; // swizzle this to match expectations\n\n  // project our vertex position\n  vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\n  IN_viewPos = mvPosition.xyz;\n  IN_viewNormal = normalize(transformedNormal);\n  IN_instanceAndTypeId = instanceAndTypeId.xy;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n\n";
var fragmentShader = "\nprecision highp float;\n\nin vec3 IN_viewPos;\nin vec3 IN_viewNormal;\nin vec2 IN_instanceAndTypeId;\n\nlayout(location = 0) out vec4 gAgentInfo;\nlayout(location = 1) out vec4 gNormal;\nlayout(location = 2) out vec4 gPos;\n\nuniform mat4 projectionMatrix;\n\nvoid main()\t{\n    vec3 fragViewPos = IN_viewPos;\n  \n    vec4 fragPosClip = projectionMatrix * vec4(fragViewPos, 1.0);\n    vec3 fragPosNDC = fragPosClip.xyz / fragPosClip.w;\n    float n = gl_DepthRange.near;\n    float f = gl_DepthRange.far;\n    // TODO: is this the same as gl_FragCoord.z ???\n    float fragPosDepth = (((f - n) * fragPosNDC.z) + n + f) / 2.0;\n\n    // type id, instance id, zEye, zFragDepth\n    gAgentInfo = vec4(IN_instanceAndTypeId.y, IN_instanceAndTypeId.x, fragViewPos.z, fragPosDepth);\n\n    vec3 normal = IN_viewNormal;\n    normal = normalize(normal);\n    gNormal = vec4(normal * 0.5 + 0.5, 1.0);\n\n    gPos = vec4(fragViewPos.x, fragViewPos.y, fragViewPos.z, 1.0);\n}\n";

function createShaders(lengthSegments, nPointsPerCurve) {
  var shaderDefines = {
    lengthSegments: lengthSegments,
    ROBUST: false,
    ROBUST_NORMAL: true,
    // can be disabled for a slight optimization
    FLAT_SHADED: false,
    NUM_POINTS: nPointsPerCurve
  };
  var multiMaterial = new RawShaderMaterial({
    glslVersion: GLSL3,
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    side: FrontSide,
    transparent: false,
    defines: _objectSpread({}, shaderDefines),
    uniforms: {
      curveData: {
        value: null
      },
      projectionMatrix: {
        value: new Matrix4()
      },
      modelViewMatrix: {
        value: new Matrix4()
      }
    }
  });
  return {
    mat: multiMaterial
  };
}

export { createShaders };